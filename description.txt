
This is a description, and request for feedback, of the unittest plugin system that I am currently prototyping in the plugins branch of unittest2_. My goal is to merge the plugin system back into unittest itself in Python 3.2.

.. _unittest2: http://hg.python.org/unittest2

As part of the prototype I have been implementing some example plugins (in unittest2/plugins/) so I can develop the mechanism to real rather than imagined use cases. Jason Pellerin, creator of nose, has been providing me with feedback and has been trying out by porting some of the nose plugins to unittest [#]_. He comments on the system "it looks very flexible and clean". ;-)

Example plugins already available:

    * a pep8 and pyflakes checker
    * a debugger plugin that drops you into pdb on test fail / error
    * a doctest loader (looks for doctests in all text files in the project)
    * use a regex for matching files in test discovery instead of a glob
    * growl notifications on test run start and stop
    * filter individual *test methods* using a regex
    * load test functions from modules as well as TestCases
    * integration with the coverage module for coverage reporting

In addition I intend to create a plugin that outputs junit compatible xml from a test run (for integration with tools like the hudson continuous integration server) and a test runner that runs tests in parallel using multiprocessing.

I'd like feedback on the proposal, and hopefully approval to port it into unittest after discussion / amendment / completion. In particular I'd like feedback on the basic system, plus which events should be available and what information should be available in them. Note that the system is *not* complete in the prototype. Enough is implemented to get "the general idea" and to formalise the full system. It still needs extensive tests and the extra work in TestProgram makes it abundantly clear that refactoring there is well overdue...

In the details below open questions and todos are notes. I *really* value feedback but will ignore bikeshedding. ;-)

.. note::

    Throughout this document I refer to the prototype implementation using names like ``unittest2.events.hooks``. Should this proposal be accepted then the names will live in the unittest package instead of unittest2.
    
    The core classes for the event system live in the current implementation in the ``unittest2.events`` namespace.


Abstract
========

unittest lacks a standard way of extending it to provide commonly requested functionality, other than subclassing and overriding (and reimplementing) parts of its behaviour. This document describes a plugin system already partially prototyped in unittest2.

Aspects of the plugin system include:

* an events mechanism where handlers can be registered and called during a test run
* a Plugin class built over the top of this for easy building of plugins
* a configuration system for specify which plugins should be loaded and configuring individual plugins
* command line integration
* the specific set of events and the information / actions available to them

As the plugin system essentially just adds event calls to key places it has few backwards compatibility issues. Unfortunately existing extensions that override the parts of unittest that call these events will not be compatible with plugins that use them. Framework authors who re-implement parts of unittest, for example custom test runners, may want to add calling these events in appropriate places.


Rationale
=========

Why a plugin system for unittest?

unittest is the standard library test framework for Python but in recent years has been eclipsed in functionality by frameworks like nose and py.test. Among the reasons for this is that these frameworks are easier to extend with plugin systems that unittest. unittest makes itself particularly difficult to extend by using subclassing as its basic extension mechanism. You subclass and override behaviour in its core classes like the loader, runner and result classes.

This means that where you have more than one "extension" working in the same area it is very hard for them to work together. Whilst various extensions to unittest do exist (e.g. testtools, zope.testrunner etc) they don't tend to work well together. In contrast the plugin system makes creating extensions to unittest much simpler and less likely that extensions will clash with each other.

nose itself exists as a large system built over the top of unittest. Extending unittest in this way was very painful for the creators of nose, and every release of Python breaks nose in some way due to changes in unittest. One of the goals of the extension mechanism is to allow nose2 to be a much thinner set of plugins over unittest(2) that is much simpler to maintain [#]_. The early indications are that the proposed system is a good fit for this goal.


Low Level Mechanism
====================

The basic mechanism is having events fired at various points during a test run. Plugins can register event handler functions that will be called with an event object. Multiple functions may be registered to handle an event and event handlers can also be removed.

Over the top of this is a ``Plugin`` class that simplifies building plugins on top of this mechanism. This is described in a separate section.

The events live on the ``unittest2.events.hooks`` class. Handlers are added using ``+=`` and removed using ``-=``, a syntax borrowed from the .NET system.

For example adding a handler for the ``startTestRun`` event::

    from unittest2.events import hooks
    
    def startTestRun(event):
        print 'test run started at %s' % event.startTime
    
    hooks.startTestRun += startTestRun

Handlers are called with an Event object specific to the event. Each event provides different information on its event objects as attributes. For example the attributes available on ``StartTestRunEvent`` objects are:

* ``suite`` - the test suite for the full test run
* ``runner`` - the test runner
* ``result`` - the test result
* ``startTime``

The name of events, whether any should be added or removed, and what information is available on the event objects are all valid topics for discussion. Specific events and the information available to them is covered in a section below.

An example plugin using events directly is the ``doctestloader`` plugin.

Framework authors who re-implement parts of unittest, for example custom test runners, may want to add calling these events in appropriate places. This is very simple. For example the ``pluginsLoaded`` event is fired with a ``PluginsLoadedEvent`` object that is instantiated without parameters::

    from unittest2.events import hooks, PluginsLoadedEvent

    hooks.pluginsLoaded(PluginsLoadedEvent())


Why use event objects and not function parameters?
--------------------------------------------------

There are several reasons to use event objects instead of function parameters. The *disadvantage* of this is that the information available to an event is not obvious from the signature of a handler. There are several compelling advantages however:

* the signature of all handler functions is identical and therefore easy to remember

* backwards compatibility - new attributes can be added to event objects (and parameters deprecated) without breaking existing plugins. Changing the way a function is called (unless all handlers have a ``**kw`` signature) is much harder.

* several of the events have a lot of information available. This would make the signature of handlers huge. With an event object handlers only need to be aware of attributes they are interested in and ignore information they aren't interested in ("only pay for what you eat").

* some of the attributes are mutable - the event object is shared between all handlers, this would be less obvious if function parameters were used

* calling multiple handlers and still returning a value (see the handled pattern below)


The handled pattern
--------------------

Several events can be used to *override* the default behaviour. For example the 'matchregexp' plugin uses the ``matchPath`` event to replace the default way of matching files for loading as tests during test discovery. The handler signals that it is handling this event, and the default implementation should not be run, by setting ``event.handled = True``::

    def matchRegexp(event):
        pattern = event.pattern
        name = event.name
        event.handled = True
        path = event.path
        if matchFullPath:
            return re.match(pattern, path)
        return re.match(pattern, name)

Where the default implementation returns a value, for example creating a test suite, or in the case of ``matchPath`` deciding if a path matches a file that should be loaded as a test, the handler can return a result.

If an event sets handled on an event then no more handlers will be called for that event. Which events can be handled, and which not, is discussed in the events section.


The Plugin Class
================

A sometimes-more-convenient way of creating plugins is to subclass the ``unittest2.events.Plugin`` class. By default subclassing ``Plugin`` will auto-instantiate the plugin and store the instance in a list of loaded plugins.

Each plugin has a ``register()`` method that auto-hooks up all methods whose names correspond to events. Plugin classes may also provide ``configSection`` and ``commandLineSwitch`` class attributes which simplifies enabling the plugin through the command line and making available a section from the configuration file(s).

A simple plugin using this is the 'debugger' plugin that starts ``pdb`` when the ``onTestFail`` event fires::

    from unittest2.events import Plugin

    import pdb
    import sys

    class Debugger(Plugin):

        configSection = 'debugger'
        commandLineSwitch = ('D', 'debugger', 'Enter pdb on test fail or error')
    
        def __init__(self):
            self.errorsOnly = self.config.as_bool('errors-only', default=False)

        def onTestFail(self, event):
            value, tb = event.exc_info[1:]
            test = event.test
            if self.errorsOnly and isinstance(value, test.failureException):
                return
            original = sys.stdout
            sys.stdout = sys.__stdout__
            try:
                pdb.post_mortem(tb)
            finally:
                sys.stdout = original

A plugin that doesn't want to be auto-instantiated (for example a base class used for several plugins) can set ``autoCreate = False`` as a class attribute. (This attribute is only looked for on the class directly and so isn't inherited by sub-classes.) If a plugin is auto-instantiated then the instance will be set as the ``instance`` attribute on the plugin class.

``configSection`` and ``commandLineSwitch`` are described in the `configuration system`_ and `command line integration`_ sections.

Plugin instances also have an ``unregister`` method that unhooks all events. It doesn't exactly correspond to the ``register`` method (it undoes some of the work done when a plugin is instantiated) and so can only be called once.

Plugins to be loaded are specified in configuration files. For frameworks not using the unittest test runner and configuration system APIs for loading plugins are available in the form of the ``loadPlugins`` function (which uses the configuration system to load plugins) and ``loadPlugin`` which loads an individual plugin by module name. Loading plugins just means importing the module containing the plugin.



Configuration system
====================

By default the unittest2 test runner (triggered by the unit2 script or for unittest ``python -m unittest``) loads two configuration files to determine which plugins to load.

A user configuration file, ~/unittest.cfg (alternative name and location would be possible), can specify plugins that will always be loaded. A per-project configuration file, unittest.cfg which should be located in the current directory when unit2 is launched, can specify plugins for individual projects.

To support this system several command line options have been added to the test runner::

  --config=CONFIGLOCATIONS
                        Specify local config file location
  --no-user-config      Don't use user config file
  --no-plugins          Disable all plugins

Several config files can be specified using ``--config``. If the user config is being loaded then it will be loaded first (if it exists), followed by the project config (if it exists) *or* any config files specified by ``--config``. ``--config`` can point to specific files, or to a directory containing a ``unittest.cfg``.

Config files loaded later are merged into already loaded ones. Where a *key* is in both the later key overrides the earlier one. Where a section is in both but with different keys they are merged. (The exception to keys overriding is the 'plugins' key in the unittest section - these are combined to create a full list of plugins. Perhaps multiline values in config files could also be merged?)

plugins to be loaded are specified in the ``plugins`` key of the ``unittest`` section::

    [unittest]
    plugins = 
        unittest2.plugins.checker
        unittest2.plugins.doctestloader
        unittest2.plugins.matchregexp
        unittest2.plugins.moduleloading
        unittest2.plugins.debugger
        unittest2.plugins.testcoverage
        unittest2.plugins.growl
        unittest2.plugins.filtertests

The plugins are simply module names. They either hook themselves up manually on import or are created by virtue of subclassing ``Plugin``. A list of all loaded plugins is available as ``unittest2.events.loadedPlugins`` (a list of strings).

For accessing config values there is a ``getConfig(sectionName=None)`` function. By default it returns the whole config data-structure but it an also return individual sections by name. If the section doesn't exist an empty section will be returned. The config data-structure is not read-only but there is no mechanism for persisting changes.

The config is a dictionary of ``Section`` objects, where a section is a dictionary subclass with some convenience methods for accessing values::

    section = getConfig(sectionName)
    
    integer = section.as_int('foo', default=3)
    number = section.as_float('bar', default=0.0)
    
    # as_list returns a list with empty lines and comment lines removed
    items = section.as_list('items', default=[])
    value = section.as_bool('value', default=True)

If a plugin specifies a ``configSection`` as a class attribute then that section will be fetched and set as the ``config`` attribute on instances.

By convention plugins should use the 'always-on' key in their config section to specify that the plugin should be switched on by default. If 'always-on' exists and is set to 'True' then the ``register()`` method will be called on the plugin to hook up all events. If you don't want a plugin to be auto-registered you should fetch the config section yourself rather than using ``configSection``.

If the plugin is configured to be 'always-on', and is auto-registered, then it doesn't need a command line switch to turn it on (although it may add other command line switches or options) and ``commandLineSwitch`` will be ignored.


Command Line Interface
======================

Plugins may add command line options, either switches with a callback function or options that take values and will be added to a list. There are two functions that do this: ``unittest2.events.addOption`` and ``unittest2.events.addDiscoveryOption``. Some of the events are only applicable to test discovery (``matchPath`` is the only one currently I think), options that use these events should use ``addDiscoveryOption`` which will only be used if test discovery is invoked.

Both functions have the same signature::

    addDiscoveryOption(callback, opt=None, longOpt=None, help=None)
    
    addOption(plugin.method, 'X', '--extreme', 'Run tests in extreme mode')

* ``callback`` is a callback function (taking no arguments) to be invoked if the option is on *or* a list indicating that this is an option that takes arguments, values passed in at the command line will be added to the list
* ``opt`` is a short option for the command (or None) not including the leading '-'
* ``longopt`` a long option for the command (or None) not including the leading '--'
* ``help`` is optional help text for the option, to be displayed by ``unit2 -h``

Lowercase short options are reserved for use by unittest2 internally. Plugins may only add uppercase short options.

If a plugin needs a simple command line switch (on/off) then it can set the ``commandLineSwitch`` class attribute to a tuple of ``(opt, longOpt, help)``. The ``register()`` method will be used as the callback function, automatically hooking the plugin up to events if it is switched on.


The Events
==========

This section details the events implemented so far, the order they are called in, what attributes are available on the event objects, whether the event is 'handleable' (and what that means for the event), plus the intended use case for the event.

Events in rough order are:

* ``pluginsLoaded``
* ``handleFile``
* ``matchPath``
* ``loadTestsFromNames``
* ``loadTestsFromName``
* ``loadTestsFromModule``
* ``loadTestsFromTestCase``
* ``getTestCaseNames``
* ``runnerCreated``
* ``startTestRun``
* ``startTest``
* ``onTestFail``
* ``stopTest``
* ``stopTestRun``


pluginsLoaded
-------------

This event is useful for plugin initialisation. It is fired after all plugins have been loaded, the config file has been read and command line options processed.

The ``PluginsLoadedEvent``  has one attribute: ``loadedPlugins`` which is a list of strings referring to all plugin modules that have been loaded.


handleFile
----------

This event is fired when a file is looked at in test discovery or a *filename* is passed at the command line. It can be used for loading tests from non-Python files, like doctests from text files, or adding tests for a file like pep8 and pyflakes checks.

A ``HandleFileEvent`` object has the following attributes:

* ``extraTests`` - a list, extend this with tests to *add* tests that will be loaded from this file without preventing the default test loading
* ``name`` - the name of the file
* ``path`` - the full path of the file being looked at
* ``loader`` - the ``TestLoader`` in use
* ``pattern`` - the pattern being used to match files, or None if not called during test discovery
* ``top_level_directory`` - the top level directory of the project tests are being loaded from, or the current working directory if not called during test discovery

This event *can* be handled. If it is handled then the handler should return a test suite or None. Returning None means no tests will be loaded from this file. If any plugin has created any ``extraTests`` then these will be used even if a handler handles the event and returns None.

If this event is not handled then it will be matched against the pattern (test discovery only) and either be rejected or go through for standard test loading.


matchPath
---------

``matchPath`` is called to determine if a file should be loaded as a test module. This event only fires during test discovery.

``matchPath`` is only fired if the filename can be converted to a valid python module name, this is because tests are loaded by importing. If you want to load tests from files whose paths don't translate to valid python identifiers then you should use ``handleFile`` instead.

A ``MatchPathEvent`` has the following attributes:

* ``path`` - full path to the file
* ``name`` - filename only
* ``pattern`` - pattern being used for discovery

This event *can* be handled. If it is handled then the handler should return True or False to indicate whether or not test loading should be attempted from this file. If this event is not handled then the pattern supplied to test discovery will be used as a glob pattern to match the filename.


loadTestsFromNames
------------------

This event is fired when ``TestLoader.loadTestsFromNames`` is called.

Attributes on the ``LoadFromNamesEvent`` object are:

* ``loader`` - the test loader
* ``names`` - a list of the names being loaded
* ``module`` - the module passed to ``loader.loadTestsFromNames(...)`` 
* ``extraTests`` - a list of extra tests to be added to the suites loaded from the names

This event can be handled. If it is handled then the handler should return a list of suites or None. Returning None means no tests will be loaded from these names. If any plugin has created any ``extraTests`` then these will be used even if a handler handles the event and returns None.

If this event is not handled then ``loader.loadTestFromName`` will be called for each name to build up the list of suites.


loadTestsFromName
-----------------

This event is fired when ``TestLoader.loadTestsFromName`` is called.

Attributes on the ``LoadFromNameEvent`` object are:

* ``loader`` - the test loader
* ``name`` - the name being loaded
* ``module`` - the module passed to ``loader.loadTestsFromName(...)`` 
* ``extraTests`` - a suite of extra tests to be added to the suite loaded from the name

This event can be handled. If it is handled then the handler should return a TestSuite or None. Returning None means no tests will be loaded from this name. If any plugin has created any ``extraTests`` then these will be used even if a handler handles the event and returns None.

If the event is not handled then each name will be resolved and tests loaded from it, which may mean calling ``loader.loadTestsFromModule`` or ``loader.loadTestsFromTestCase``.


* ``loadTestsFromModule``
* ``loadTestsFromTestCase``
* ``getTestCaseNames``
* ``runnerCreated``
* ``startTestRun``
* ``startTest``
* ``onTestFail``
* ``stopTest``
* ``stopTestRun``


Not Yet Implemented
===================


Additional Changes
==================

Alongside, and in support of, the plugin system a few changes have been made to unittest2. These either have no, or very minor, backwards compatibility issues. Changes so far are:

TestLoader has a new attribute ``DEFAULT_PATTERN``. This is so that the
regex matching plugin can change the default pattern used for test discovery
when no pattern is explicitly provided.

Command line parsing is all done by optparse, removing the use of getopt. This
makes the help messages more consistent but makes the usage messages less
useful in some situations. This can be fixed with the use of the optparse
epilogue.

unit2 (the default test runner) runs test discovery if invoked without any arguments.

unit2 can execute tests in filenames as well as module names - so long as the
module pointed to by the filename is importable from the current directory.

FunctionTestCase.id() returns 'module.funcname' instead of just funcname.

Added util.formatTraceback, the default way of formatting tracebacks. TestCase
has a new formatTraceback method (delegating to util.formatTraceback). TestCase
instances can implement formatTraceback to control how the traceback for errors
and failures are represented. Useful for test items that don't represent Python
tests, for example the pep8 / pyflakes checker and theoretical javascript
test runners such as exist for py.test and nose.

If you specify test names (modules, classes etc) at the command line they will
be loaded individually using ``loader.loadTestsFromName`` instead of
collectively with ``loader.loadTestsFromNames``. This enables individual names
to be checked to see if they refer to filenames.


References
==========

.. [#] See http://bitbucket.org/jpellerin/unittest2/src/tip/unittest2/plugins/attrib.py and http://bitbucket.org/jpellerin/unittest2/src/tip/unittest2/plugins/errormaster.py
.. [#] http://lists.idyll.org/pipermail/testing-in-python/2010-March/002799.html